import google.generativeai as genai
from typing import Dict, List, Optional
from app.core.config import settings
from app.core.database import get_db
from sqlalchemy.orm import Session
from sqlalchemy import text

class AIService:
    def __init__(self):
        # C·∫•u h√¨nh Gemini AI
        genai.configure(api_key="AIzaSyCIEnHLUvhcB_fO1vnMQQ7w9BR72qhNLPo")
        self.model = genai.GenerativeModel('gemini-2.5-flash')
        
    def generate_response(self, user_question: str, context: Optional[Dict] = None) -> str:
        """
        T·∫°o ph·∫£n h·ªìi t·ª´ AI d·ª±a tr√™n c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng v√† context t·ª´ database
        """
        try:
            # L·∫•y context t·ª´ database n·∫øu c√≥
            db_context = ""
            if context:
                db_context = self._get_database_context(context)
            
            # T·∫°o prompt cho AI
            prompt = self._create_prompt(user_question, db_context)
            
            # G·ªçi Gemini AI
            response = self.model.generate_content(prompt)
            
            return response.text
            
        except Exception as e:
            return f"Xin l·ªói, t√¥i g·∫∑p l·ªói khi x·ª≠ l√Ω c√¢u h·ªèi c·ªßa b·∫°n: {str(e)}"
    
    def _create_prompt(self, question: str, db_context: str) -> str:
        """
        T·∫°o prompt cho AI v·ªõi context t·ª´ database
        """
        prompt = f"""
        B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n v·ªÅ qu·∫£n l√Ω nh√† tr·ªç v√† ph√≤ng cho thu√™. 
        
        Th√¥ng tin hi·ªán t·∫°i t·ª´ h·ªá th·ªëng:
        {db_context}
        
        C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng: {question}
        
        Y√äU C·∫¶U TR·∫¢ L·ªúI:
        - Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, ng·∫Øn g·ªçn, c√≥ c·∫•u tr√∫c r√µ r√†ng
        - S·ª≠ d·ª•ng bullet points (-) cho danh s√°ch
        - S·ª≠ d·ª•ng ## cho ti√™u ƒë·ªÅ ph·∫ßn (n·∫øu c·∫ßn)
        - S·ª≠ d·ª•ng **text** ƒë·ªÉ l√†m n·ªïi b·∫≠t th√¥ng tin quan tr·ªçng ( in ƒë·∫≠m n√≥ )
        - ƒê∆∞a ra s·ªë li·ªáu c·ª• th·ªÉ t·ª´ d·ªØ li·ªáu h·ªá th·ªëng
        - N·∫øu l√† c√¢u h·ªèi ph·ª©c t·∫°p, chia th√†nh c√°c ph·∫ßn: T√¨nh h√¨nh hi·ªán t·∫°i, Ph√¢n t√≠ch, Khuy·∫øn ngh·ªã
        - M·ªói √Ω ch√≠nh kh√¥ng qu√° 2 d√≤ng
        - S·ª≠ d·ª•ng emoji ph√π h·ª£p ƒë·ªÉ d·ªÖ ƒë·ªçc h∆°n
        """
        return prompt
    
    def _get_database_context(self, context: Dict) -> str:
        """
        L·∫•y th√¥ng tin t·ª´ database ƒë·ªÉ l√†m context cho AI, ph·∫°m vi theo ch·ªß nh√† (owner_id)
        """
        context_info = []
        owner_id = context.get('owner_id')

        try:
            db = next(get_db())
            
            # L·∫•y th·ªëng k√™ t·ªïng quan
            if context.get('include_stats', False):
                stats = self._get_system_stats(db, owner_id)
                context_info.append(f"Th·ªëng k√™ h·ªá th·ªëng (t√†i kho·∫£n b·∫°n): {stats}")

            # L·∫•y th√¥ng tin ph√≤ng tr·ªëng
            if context.get('include_available_rooms', False):
                rooms = self._get_available_rooms(db, owner_id)
                context_info.append(f"Ph√≤ng tr·ªëng hi·ªán t·∫°i: {rooms}")
            
            # L·∫•y th√¥ng tin h√≥a ƒë∆°n ch∆∞a thanh to√°n
            if context.get('include_pending_invoices', False):
                invoices = self._get_pending_invoices(db, owner_id)
                context_info.append(f"H√≥a ƒë∆°n ch∆∞a thanh to√°n: {invoices}")
            
            db.close()
            
        except Exception as e:
            context_info.append(f"L·ªói khi l·∫•y th√¥ng tin t·ª´ database: {str(e)}")
        
        return "\n".join(context_info)
    
    def _get_system_stats(self, db: Session, owner_id: int) -> str:
        """
        L·∫•y th·ªëng k√™ t·ªïng quan c·ªßa h·ªá th·ªëng theo ch·ªß nh√†
        """
        try:
            # T·ªïng s·ªë nh√† tr·ªç c·ªßa owner
            total_houses = db.execute(text(
                "SELECT COUNT(*) FROM houses WHERE owner_id = :owner_id"
            ), { 'owner_id': owner_id }).scalar()

            # T·ªïng s·ªë ph√≤ng thu·ªôc c√°c nh√† c·ªßa owner
            total_rooms = db.execute(text(
                """
                SELECT COUNT(*) 
                FROM rooms r 
                JOIN houses h ON r.house_id = h.house_id 
                WHERE h.owner_id = :owner_id
                """
            ), { 'owner_id': owner_id }).scalar()

            # S·ªë ph√≤ng ƒëang thu√™ (kh√¥ng c√≤n available)
            occupied_rooms = db.execute(text(
                """
                SELECT COUNT(*) 
                FROM rooms r 
                JOIN houses h ON r.house_id = h.house_id 
                WHERE h.owner_id = :owner_id AND r.is_available = FALSE
                """
            ), { 'owner_id': owner_id }).scalar()

            # S·ªë ph√≤ng tr·ªëng
            available_rooms = (total_rooms or 0) - (occupied_rooms or 0)

            # T·ª∑ l·ªá l·∫•p ƒë·∫ßy
            occupancy_rate = ((occupied_rooms or 0) / (total_rooms or 1) * 100) if (total_rooms or 0) > 0 else 0

            return f"T·ªïng {total_houses} nh√† tr·ªç, {total_rooms} ph√≤ng ({occupied_rooms} ƒëang thu√™, {available_rooms} tr·ªëng). T·ª∑ l·ªá l·∫•p ƒë·∫ßy: {occupancy_rate:.1f}%"
            
        except Exception as e:
            return f"Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™: {str(e)}"
    
    def _get_available_rooms(self, db: Session, owner_id: int) -> str:
        """
        L·∫•y th√¥ng tin ph√≤ng tr·ªëng theo ch·ªß nh√†
        """
        try:
            rooms = db.execute(text(
                """
                SELECT r.name, r.price, h.name as house_name 
                FROM rooms r 
                JOIN houses h ON r.house_id = h.house_id 
                WHERE r.is_available = TRUE 
                AND h.owner_id = :owner_id
                ORDER BY r.price 
                LIMIT 5
                """
            ), { 'owner_id': owner_id }).fetchall()

            if not rooms:
                return "Hi·ªán t·∫°i kh√¥ng c√≥ ph√≤ng tr·ªëng n√†o."
            
            room_list = []
            for room in rooms:
                room_list.append(f"{room.name} ({room.house_name}) - {room.price:,.0f} VNƒê")
            
            return "Ph√≤ng tr·ªëng: " + ", ".join(room_list)
            
        except Exception as e:
            return f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ph√≤ng tr·ªëng: {str(e)}"
    
    def _get_pending_invoices(self, db: Session, owner_id: int) -> str:
        """
        L·∫•y th√¥ng tin h√≥a ƒë∆°n ch∆∞a thanh to√°n theo ch·ªß nh√†
        """
        try:
            invoices = db.execute(text(
                """
                SELECT COUNT(*) as count, 
                       SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price) as total
                FROM invoices i
                JOIN rented_rooms rr ON i.rr_id = rr.rr_id
                JOIN rooms r ON rr.room_id = r.room_id
                JOIN houses h ON r.house_id = h.house_id
                WHERE i.is_paid = FALSE
                  AND h.owner_id = :owner_id
                """
            ), { 'owner_id': owner_id }).fetchone()

            count = invoices.count or 0
            total = invoices.total or 0

            if count == 0:
                return "Kh√¥ng c√≥ h√≥a ƒë∆°n ch∆∞a thanh to√°n n√†o."
            
            return f"C√≥ {count} h√≥a ƒë∆°n ch∆∞a thanh to√°n, t·ªïng ti·ªÅn: {total:,.0f} VNƒê"

        except Exception as e:
            return f"Kh√¥ng th·ªÉ l·∫•y th√¥ng tin h√≥a ƒë∆°n: {str(e)}"
    
    def get_room_recommendations(self, budget: float, capacity: int, district: str = None) -> str:
        """
        ƒê∆∞a ra g·ª£i √Ω ph√≤ng ph√π h·ª£p d·ª±a tr√™n ng√¢n s√°ch v√† y√™u c·∫ßu
        """
        try:
            db = next(get_db())
            
            # G·ªçi stored procedure ƒë·ªÉ t√¨m ph√≤ng ph√π h·ª£p
            result = db.execute(text(
                """
                CALL FindAvailableRooms(:min_price, :max_price, :min_capacity, :max_capacity, :district)
                """
            ), {
                'min_price': budget * 0.8,  # 80% ng√¢n s√°ch
                'max_price': budget * 1.2,  # 120% ng√¢n s√°ch
                'min_capacity': capacity,
                'max_capacity': capacity + 1,
                'district': district
            }).fetchall()
            
            if not result:
                return f"Kh√¥ng t√¨m th·∫•y ph√≤ng ph√π h·ª£p v·ªõi ng√¢n s√°ch {budget:,.0f} VNƒê v√† {capacity} ng∆∞·ªùi ·ªü {district or 't·∫•t c·∫£ khu v·ª±c'}."
            
            recommendations = []
            for room in result[:3]:  # L·∫•y top 3 ph√≤ng
                recommendations.append(
                    f"üè† {room.room_name} t·∫°i {room.house_name} - "
                    f"{room.capacity} ng∆∞·ªùi, {room.price:,.0f} VNƒê/th√°ng, "
                    f"{room.asset_count} t√†i s·∫£n"
                )
            
            db.close()
            
            return "G·ª£i √Ω ph√≤ng ph√π h·ª£p:\n" + "\n".join(recommendations)
            
        except Exception as e:
            return f"Kh√¥ng th·ªÉ t√¨m ph√≤ng ph√π h·ª£p: {str(e)}"
    
    def generate_revenue_report(self, start_date: str, end_date: str, owner_id: int) -> str:
        """
        T·∫°o b√°o c√°o doanh thu b·∫±ng AI (ph·∫°m vi theo ch·ªß nh√† ƒëƒÉng nh·∫≠p)
        """
        try:
            db = next(get_db())

            # T·ªïng doanh thu (ƒë√£ thanh to√°n) trong kho·∫£ng th·ªùi gian, theo owner
            total_revenue_row = db.execute(text(
                """
                SELECT COALESCE(SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price), 0) as total
                FROM invoices i
                JOIN rented_rooms rr ON i.rr_id = rr.rr_id
                JOIN rooms r ON rr.room_id = r.room_id
                JOIN houses h ON r.house_id = h.house_id
                WHERE i.is_paid = TRUE 
                  AND i.payment_date BETWEEN :start_date AND :end_date
                  AND h.owner_id = :owner_id
                """
            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()
            total_revenue = float(total_revenue_row.total or 0)

            # S·ªë h√≥a ƒë∆°n ƒë√£ thanh to√°n trong kho·∫£ng th·ªùi gian, theo owner
            paid_invoices_row = db.execute(text(
                """
                SELECT COUNT(*) as cnt
                FROM invoices i
                JOIN rented_rooms rr ON i.rr_id = rr.rr_id
                JOIN rooms r ON rr.room_id = r.room_id
                JOIN houses h ON r.house_id = h.house_id
                WHERE i.is_paid = TRUE 
                  AND i.payment_date BETWEEN :start_date AND :end_date
                  AND h.owner_id = :owner_id
                """
            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()
            paid_invoices = int(paid_invoices_row.cnt or 0)

            # S·ªë h√≥a ƒë∆°n ch∆∞a thanh to√°n theo due_date trong kho·∫£ng th·ªùi gian, theo owner
            pending_invoices_row = db.execute(text(
                """
                SELECT COUNT(*) as cnt
                FROM invoices i
                JOIN rented_rooms rr ON i.rr_id = rr.rr_id
                JOIN rooms r ON rr.room_id = r.room_id
                JOIN houses h ON r.house_id = h.house_id
                WHERE i.is_paid = FALSE 
                  AND i.due_date BETWEEN :start_date AND :end_date
                  AND h.owner_id = :owner_id
                """
            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()
            pending_invoices = int(pending_invoices_row.cnt or 0)

            # Doanh thu trung b√¨nh theo th√°ng (trong kho·∫£ng th·ªùi gian), theo owner
            avg_month_row = db.execute(text(
                """
                SELECT COALESCE(AVG(monthly_revenue), 0) as avg_rev
                FROM (
                    SELECT DATE_FORMAT(i.payment_date, '%Y-%m') as month,
                           SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price) as monthly_revenue
                    FROM invoices i
                    JOIN rented_rooms rr ON i.rr_id = rr.rr_id
                    JOIN rooms r ON rr.room_id = r.room_id
                    JOIN houses h ON r.house_id = h.house_id
                    WHERE i.is_paid = TRUE 
                      AND i.payment_date BETWEEN :start_date AND :end_date
                      AND h.owner_id = :owner_id
                    GROUP BY DATE_FORMAT(i.payment_date, '%Y-%m')
                ) t
                """
            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()
            avg_monthly_revenue = float(avg_month_row.avg_rev or 0)

            db.close()
            
            # T√≠nh b·ªï sung
            total_invoices = paid_invoices + pending_invoices
            payment_rate = (paid_invoices / total_invoices * 100) if total_invoices > 0 else 0

            # T·∫°o prompt y√™u c·∫ßu format c·ª• th·ªÉ
            prompt = f"""
            B·∫°n l√† chuy√™n gia ph√¢n t√≠ch doanh thu. H√£y t·∫°o b√°o c√°o ph√¢n t√≠ch ng·∫Øn g·ªçn, c√≥ c·∫•u tr√∫c v·ªõi d·ªØ li·ªáu sau (ph·∫°m vi t√†i kho·∫£n hi·ªán t·∫°i):
            
            DOANH THU: {start_date} ƒë·∫øn {end_date}
            - T·ªïng doanh thu: {total_revenue:,.0f} VNƒê
            - H√≥a ƒë∆°n ƒë√£ thanh to√°n: {paid_invoices}
            - H√≥a ƒë∆°n ch∆∞a thanh to√°n: {pending_invoices}
            - T·ªïng s·ªë h√≥a ƒë∆°n: {total_invoices}
            - T·ª∑ l·ªá thanh to√°n: {payment_rate:.1f}%
            - Doanh thu TB/th√°ng: {avg_monthly_revenue:,.0f} VNƒê
            
            Y√äU C·∫¶U FORMAT:
            1. B·∫Øt ƒë·∫ßu v·ªõi "## üìä PH√ÇN T√çCH DOANH THU"
            2. Ph·∫ßn "## üìà CH·ªà S·ªê CH√çNH" - li·ªát k√™ 3-4 ch·ªâ s·ªë quan tr·ªçng nh·∫•t d·∫°ng bullet point
            3. Ph·∫ßn "## ‚úÖ ƒêI·ªÇM M·∫†NH" - 2-3 ƒëi·ªÉm t√≠ch c·ª±c (n·∫øu c√≥)
            4. Ph·∫ßn "## ‚ö†Ô∏è V·∫§N ƒê·ªÄ C·∫¶N L∆ØU √ù" - 2-3 v·∫•n ƒë·ªÅ c·∫ßn c·∫£i thi·ªán (n·∫øu c√≥)
            5. Ph·∫ßn "## üí° KHUY·∫æN NGH·ªä" - 3-4 g·ª£i √Ω c·∫£i thi·ªán c·ª• th·ªÉ, ng·∫Øn g·ªçn
            
            L∆ØU √ù:
            - M·ªói bullet point PH·∫¢I ng·∫Øn g·ªçn (1-2 d√≤ng)
            - S·ª≠ d·ª•ng s·ªë li·ªáu c·ª• th·ªÉ t·ª´ d·ªØ li·ªáu tr√™n
            - Kh√¥ng vi·∫øt vƒÉn xu√¥i d√†i
            - T·∫≠p trung v√†o insights quan tr·ªçng
            - S·ª≠ d·ª•ng emoji ph√π h·ª£p cho m·ªói ph·∫ßn
            """

            response = self.model.generate_content(prompt)
            return response.text

        except Exception as e:
            return f"Kh√¥ng th·ªÉ t·∫°o b√°o c√°o doanh thu: {str(e)}"

# Kh·ªüi t·∫°o service
ai_service = AIService()
