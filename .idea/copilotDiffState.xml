<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/app/api/v2/ai.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/api/v2/ai.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from pydantic import BaseModel&#10;from datetime import datetime, date&#10;&#10;from ...core.security import get_current_active_user&#10;from ...models.user import User&#10;from ...services.ai_service import ai_service&#10;&#10;router = APIRouter()&#10;&#10;class RevenueReportRequest(BaseModel):&#10;    start_date: date&#10;    end_date: date&#10;&#10;@router.post(&quot;/generate-revenue-report&quot;)&#10;async def generate_revenue_report(&#10;    request: RevenueReportRequest,&#10;    current_user: User = Depends(get_current_active_user)&#10;):&#10;    &quot;&quot;&quot;&#10;    Tạo báo cáo doanh thu bằng AI (phạm vi tài khoản đang đăng nhập)&#10;    &quot;&quot;&quot;&#10;    try:&#10;        report = ai_service.generate_revenue_report(&#10;            start_date=request.start_date.strftime('%Y-%m-%d'),&#10;            end_date=request.end_date.strftime('%Y-%m-%d'),&#10;            owner_id=current_user.owner_id&#10;        )&#10;&#10;        return {&#10;            &quot;report&quot;: report,&#10;            &quot;period&quot;: f&quot;{request.start_date} đến {request.end_date}&quot;,&#10;            &quot;timestamp&quot;: datetime.now()&#10;        }&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Lỗi AI service: {str(e)}&quot;)&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from pydantic import BaseModel&#10;from datetime import datetime, date&#10;&#10;from ...core.security import get_current_active_user&#10;from ...models.user import User&#10;from ...services.ai_service import ai_service&#10;&#10;router = APIRouter()&#10;&#10;class RevenueReportRequest(BaseModel):&#10;    start_date: date&#10;    end_date: date&#10;&#10;@router.post(&quot;/generate-revenue-report&quot;)&#10;async def generate_revenue_report(&#10;    request: RevenueReportRequest,&#10;    current_user: User = Depends(get_current_active_user)&#10;):&#10;    &quot;&quot;&quot;&#10;    Tạo báo cáo doanh thu bằng AI (phạm vi tài khoản đang đăng nhập)&#10;    &quot;&quot;&quot;&#10;    try:&#10;        report = ai_service.generate_revenue_report(&#10;            start_date=request.start_date.strftime('%Y-%m-%d'),&#10;            end_date=request.end_date.strftime('%Y-%m-%d'),&#10;            owner_id=current_user.owner_id&#10;        )&#10;&#10;        return {&#10;            &quot;report&quot;: report,&#10;            &quot;period&quot;: f&quot;{request.start_date} đến {request.end_date}&quot;,&#10;            &quot;timestamp&quot;: datetime.now()&#10;        }&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Lỗi AI service: {str(e)}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/core/config.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/core/config.py" />
              <option name="originalContent" value="from pydantic_settings import BaseSettings&#10;&#10;class Settings(BaseSettings):&#10;    # database_url: str = &quot;mysql+pymysql://root:Tien3859%40@localhost:3306/room_management_db&quot;&#10;    database_url: str = &quot;mysql+pymysql://Jellalaz:Qn6starz%40@127.0.0.1:3306/room_management_db&quot;&#10;    secret_key: str = &quot;your-secret-key-here-change-in-production&quot;&#10;    algorithm: str = &quot;HS256&quot;&#10;    access_token_expire_minutes: int = 30&#10;    # Gemini AI API&#10;&#10;    # --------&gt;  Bỏ comment dòng dưới ra ( nếu bị comment ) để kích hoạt api_key ._.   &lt;-------&#10;    gemini_api_key: str = &quot;AIzaSyCev4E5F6IT5OaOAXKwhk2xqtO-309WFB4&quot;&#10;    &#10;    class Config:&#10;        env_file = &quot;.env&quot;&#10;&#10;settings = Settings()&#10;" />
              <option name="updatedContent" value="from pydantic_settings import BaseSettings&#10;&#10;class Settings(BaseSettings):&#10;    # database_url: str = &quot;mysql+pymysql://root:Tien3859%40@localhost:3306/room_management_db&quot;&#10;    database_url: str = &quot;mysql+pymysql://Jellalaz:Qn6starz%40@127.0.0.1:3306/room_management_db&quot;&#10;    secret_key: str = &quot;your-secret-key-here-change-in-production&quot;&#10;    algorithm: str = &quot;HS256&quot;&#10;    access_token_expire_minutes: int = 30&#10;    # Gemini AI API&#10;&#10;    # --------&gt;  Bỏ comment dòng dưới ra ( nếu bị comment ) để kích hoạt api_key ._.   &lt;-------&#10;    gemini_api_key: str = &quot;AIzaSyCev4E5F6IT5OaOAXKwhk2xqtO-309WFB4&quot;&#10;    &#10;    class Config:&#10;        env_file = &quot;.env&quot;&#10;&#10;settings = Settings()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/core/security.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/core/security.py" />
              <option name="originalContent" value="from datetime import datetime, timedelta&#10;from typing import Optional&#10;from jose import JWTError, jwt&#10;from passlib.context import CryptContext&#10;from fastapi import Depends, HTTPException, status&#10;from fastapi.security import OAuth2PasswordBearer&#10;from sqlalchemy.orm import Session&#10;from .config import settings&#10;from .database import get_db&#10;from ..models.user import User&#10;&#10;pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)&#10;# Point to v2 login endpoint for OAuth2 docs/consumers&#10;oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;/api/v2/auth/login&quot;)&#10;&#10;def verify_password(plain_password, hashed_password):&#10;    return pwd_context.verify(plain_password, hashed_password)&#10;&#10;def get_password_hash(password):&#10;    return pwd_context.hash(password)&#10;&#10;def get_user(db: Session, email: str):&#10;    return db.query(User).filter(User.email == email).first()&#10;&#10;def get_user_by_id(db: Session, owner_id: int):&#10;    return db.query(User).filter(User.owner_id == owner_id).first()&#10;&#10;def authenticate_user(db: Session, email: str, password: str):&#10;    user = get_user(db, email)&#10;    if not user:&#10;        return False&#10;    if not verify_password(password, user.password):&#10;        return False&#10;    return user&#10;&#10;def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):&#10;    to_encode = data.copy()&#10;    if expires_delta:&#10;        expire = datetime.utcnow() + expires_delta&#10;    else:&#10;        expire = datetime.utcnow() + timedelta(minutes=15)&#10;    to_encode.update({&quot;exp&quot;: expire})&#10;    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)&#10;    return encoded_jwt&#10;&#10;async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    try:&#10;        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])&#10;        email: Optional[str] = payload.get(&quot;sub&quot;)&#10;        owner_id: Optional[int] = payload.get(&quot;oid&quot;)&#10;        if owner_id is not None:&#10;            user = get_user_by_id(db, owner_id=owner_id)&#10;        elif email is not None:&#10;            user = get_user(db, email=email)&#10;        else:&#10;            raise credentials_exception&#10;    except JWTError:&#10;        raise credentials_exception&#10;    if user is None:&#10;        raise credentials_exception&#10;    return user&#10;&#10;async def get_current_active_user(current_user: User = Depends(get_current_user)):&#10;    if not current_user.is_active:&#10;        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)&#10;    return current_user&#10;&#10;def require_role(required_role: str):&#10;    &quot;&quot;&quot;Decorator to check if user has required role&quot;&quot;&quot;&#10;    async def role_checker(current_user: User = Depends(get_current_active_user), db: Session = Depends(get_db)):&#10;        # Load role relationship if not already loaded&#10;        if not hasattr(current_user, 'role') or current_user.role is None:&#10;            db.refresh(current_user, ['role'])&#10;        &#10;        if current_user.role.authority != required_role:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Access denied. Required role: {required_role}&quot;&#10;            )&#10;        return current_user&#10;    return role_checker&#10;" />
              <option name="updatedContent" value="from datetime import datetime, timedelta&#10;from typing import Optional&#10;from jose import JWTError, jwt&#10;from passlib.context import CryptContext&#10;from fastapi import Depends, HTTPException, status&#10;from fastapi.security import OAuth2PasswordBearer&#10;from sqlalchemy.orm import Session&#10;from .config import settings&#10;from .database import get_db&#10;from ..models.user import User&#10;&#10;pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)&#10;# Point to v2 login endpoint for OAuth2 docs/consumers&#10;oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;/api/v2/auth/login&quot;)&#10;&#10;def verify_password(plain_password, hashed_password):&#10;    return pwd_context.verify(plain_password, hashed_password)&#10;&#10;def get_password_hash(password):&#10;    return pwd_context.hash(password)&#10;&#10;def get_user(db: Session, email: str):&#10;    return db.query(User).filter(User.email == email).first()&#10;&#10;def get_user_by_id(db: Session, owner_id: int):&#10;    return db.query(User).filter(User.owner_id == owner_id).first()&#10;&#10;def authenticate_user(db: Session, email: str, password: str):&#10;    user = get_user(db, email)&#10;    if not user:&#10;        return False&#10;    if not verify_password(password, user.password):&#10;        return False&#10;    return user&#10;&#10;def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):&#10;    to_encode = data.copy()&#10;    if expires_delta:&#10;        expire = datetime.utcnow() + expires_delta&#10;    else:&#10;        expire = datetime.utcnow() + timedelta(minutes=15)&#10;    to_encode.update({&quot;exp&quot;: expire})&#10;    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)&#10;    return encoded_jwt&#10;&#10;async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    try:&#10;        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])&#10;        email: Optional[str] = payload.get(&quot;sub&quot;)&#10;        owner_id: Optional[int] = payload.get(&quot;oid&quot;)&#10;        if owner_id is not None:&#10;            user = get_user_by_id(db, owner_id=owner_id)&#10;        elif email is not None:&#10;            user = get_user(db, email=email)&#10;        else:&#10;            raise credentials_exception&#10;    except JWTError:&#10;        raise credentials_exception&#10;    if user is None:&#10;        raise credentials_exception&#10;    return user&#10;&#10;async def get_current_active_user(current_user: User = Depends(get_current_user)):&#10;    if not current_user.is_active:&#10;        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)&#10;    return current_user&#10;&#10;def require_role(required_role: str):&#10;    &quot;&quot;&quot;Decorator to check if user has required role&quot;&quot;&quot;&#10;    async def role_checker(current_user: User = Depends(get_current_active_user), db: Session = Depends(get_db)):&#10;        # Load role relationship if not already loaded&#10;        if not hasattr(current_user, 'role') or current_user.role is None:&#10;            db.refresh(current_user, ['role'])&#10;        &#10;        if current_user.role.authority != required_role:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Access denied. Required role: {required_role}&quot;&#10;            )&#10;        return current_user&#10;    return role_checker" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from .core.database import engine, Base&#10;# Ensure models are imported so SQLAlchemy registers all tables before create_all&#10;from .models import user, house, room, asset, rented_room, invoice  # noqa: F401&#10;from .api.v2.api import api_router&#10;&#10;# Create database tables&#10;Base.metadata.create_all(bind=engine)&#10;&#10;app = FastAPI(title=&quot;Room Management API&quot;, version=&quot;2.0.0&quot;)&#10;&#10;# CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&quot;*&quot;],  # In production, specify exact origins&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Include API router&#10;app.include_router(api_router, prefix=&quot;/api/v2&quot;)&#10;&#10;@app.get(&quot;/&quot;)&#10;def read_root():&#10;    return {&quot;message&quot;: &quot;Room Management API is running&quot;}&#10;" />
              <option name="updatedContent" value="from fastapi import FastAPI&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from .core.database import engine, Base&#10;# Ensure models are imported so SQLAlchemy registers all tables before create_all&#10;from .models import user, house, room, asset, rented_room, invoice  # noqa: F401&#10;from .api.v2.api import api_router&#10;&#10;# Create database tables&#10;Base.metadata.create_all(bind=engine)&#10;&#10;app = FastAPI(title=&quot;Room Management API&quot;, version=&quot;2.0.0&quot;)&#10;&#10;# CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&quot;*&quot;],  # In production, specify exact origins&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Include API router&#10;app.include_router(api_router, prefix=&quot;/api/v2&quot;)&#10;&#10;@app.get(&quot;/&quot;)&#10;def read_root():&#10;    return {&quot;message&quot;: &quot;Room Management API is running&quot;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/app/services/ai_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/services/ai_service.py" />
              <option name="originalContent" value="import google.generativeai as genai&#10;from ..core.config import settings&#10;from ..core.database import get_db&#10;from sqlalchemy import text&#10;import re&#10;&#10;class AIService:&#10;    def __init__(self):&#10;        # Cấu hình Gemini AI (dùng key từ config, không hardcode)&#10;        genai.configure(api_key=settings.gemini_api_key)&#10;        # Dùng model ổn định, phổ biến&#10;        self.model = genai.GenerativeModel('gemini-2.5-pro')&#10;&#10;    def _sanitize_markdown(self, content: str) -&gt; str:&#10;        &quot;&quot;&quot;Chuẩn hoá Markdown: chỉ dùng '-' cho bullet, bỏ ký tự lạ/emoji/fences, gọn dòng.&quot;&quot;&quot;&#10;        if not content:&#10;            return content&#10;        lines = content.splitlines()&#10;        out = []&#10;        for raw in lines:&#10;            line = raw.strip()&#10;            # Bỏ code fences&#10;            if line in (&quot;```&quot;, &quot;```markdown&quot;, &quot;```md&quot;):&#10;                continue&#10;            # Thay bullet lạ ở đầu dòng thành '- '&#10;            if re.match(r&quot;^[•—–]+\s*&quot;, line):&#10;                line = re.sub(r&quot;^[•—–]+\s*&quot;, &quot;- &quot;, line)&#10;            # Thay '•', '—', '–' xuất hiện đầu dòng sau khoảng trắng&#10;            line = re.sub(r&quot;^\s*[•—–]\s*&quot;, &quot;- &quot;, line)&#10;            # Chuẩn hoá bullet '-'&#10;            line = re.sub(r&quot;^\s*-\s*&quot;, &quot;- &quot;, line)&#10;            # Loại bỏ dòng chỉ gồm gạch trang trí&#10;            if re.fullmatch(r&quot;[-–—\s]+&quot;, line):&#10;                continue&#10;            # Bỏ emoji phổ biến ở đầu dòng tiêu đề&#10;            line = re.sub(r&quot;^(##\s*)[\u2600-\u27BF\U0001F300-\U0001FAFF]\s*&quot;, r&quot;\1&quot;, line)&#10;            # Bỏ emoji đầu dòng bullet&#10;            line = re.sub(r&quot;^(-\s*)[\u2600-\u27BF\U0001F300-\U0001FAFF]\s*&quot;, r&quot;\1&quot;, line)&#10;            out.append(line)&#10;        # Ghép lại và rút gọn nhiều dòng trống liên tiếp&#10;        text_out = &quot;\n&quot;.join(out)&#10;        text_out = re.sub(r&quot;\n{3,}&quot;, &quot;\n\n&quot;, text_out).strip()&#10;        return text_out&#10;&#10;    def generate_revenue_report(self, start_date: str, end_date: str, owner_id: int) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Tạo báo cáo doanh thu bằng AI (phạm vi theo chủ nhà đăng nhập)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            db = next(get_db())&#10;&#10;            # Tổng doanh thu (đã thanh toán) trong khoảng thời gian, theo owner&#10;            total_revenue_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COALESCE(SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price), 0) as total&#10;                FROM invoices i&#10;                JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                JOIN rooms r ON rr.room_id = r.room_id&#10;                JOIN houses h ON r.house_id = h.house_id&#10;                WHERE i.is_paid = TRUE &#10;                  AND i.payment_date BETWEEN :start_date AND :end_date&#10;                  AND h.owner_id = :owner_id&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            total_revenue = float(total_revenue_row.total or 0)&#10;&#10;            # Số hóa đơn đã thanh toán trong khoảng thời gian, theo owner&#10;            paid_invoices_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COUNT(*) as cnt&#10;                FROM invoices i&#10;                JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                JOIN rooms r ON rr.room_id = r.room_id&#10;                JOIN houses h ON r.house_id = h.house_id&#10;                WHERE i.is_paid = TRUE &#10;                  AND i.payment_date BETWEEN :start_date AND :end_date&#10;                  AND h.owner_id = :owner_id&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            paid_invoices = int(paid_invoices_row.cnt or 0)&#10;&#10;            # Số hóa đơn chưa thanh toán theo due_date trong khoảng thời gian, theo owner&#10;            pending_invoices_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COUNT(*) as cnt&#10;                FROM invoices i&#10;                JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                JOIN rooms r ON rr.room_id = r.room_id&#10;                JOIN houses h ON r.house_id = h.house_id&#10;                WHERE i.is_paid = FALSE &#10;                  AND i.due_date BETWEEN :start_date AND :end_date&#10;                  AND h.owner_id = :owner_id&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            pending_invoices = int(pending_invoices_row.cnt or 0)&#10;&#10;            # Doanh thu trung bình theo tháng (trong khoảng thời gian), theo owner&#10;            avg_month_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COALESCE(AVG(monthly_revenue), 0) as avg_rev&#10;                FROM (&#10;                    SELECT DATE_FORMAT(i.payment_date, '%Y-%m') as month,&#10;                           SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price) as monthly_revenue&#10;                    FROM invoices i&#10;                    JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                    JOIN rooms r ON rr.room_id = r.room_id&#10;                    JOIN houses h ON r.house_id = h.house_id&#10;                    WHERE i.is_paid = TRUE &#10;                      AND i.payment_date BETWEEN :start_date AND :end_date&#10;                      AND h.owner_id = :owner_id&#10;                    GROUP BY DATE_FORMAT(i.payment_date, '%Y-%m')&#10;                ) t&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            avg_monthly_revenue = float(avg_month_row.avg_rev or 0)&#10;&#10;            db.close()&#10;            &#10;            # Tính bổ sung&#10;            total_invoices = paid_invoices + pending_invoices&#10;            payment_rate = (paid_invoices / total_invoices * 100) if total_invoices &gt; 0 else 0&#10;&#10;            # Prompt chuẩn Markdown, KHÔNG emoji/ký tự lạ, KHÔNG câu mở đầu/kết luận&#10;            prompt = f&quot;&quot;&quot;&#10;            Bạn là chuyên gia phân tích doanh thu. Hãy trả lời bằng Markdown, đúng định dạng sau và KHÔNG thêm ký tự trang trí/emoji:&#10;&#10;            ## PHÂN TÍCH DOANH THU&#10;            - **Kỳ báo cáo:** {start_date} - {end_date}&#10;&#10;            ## CHỈ SỐ CHÍNH&#10;            - **Tổng doanh thu:** {total_revenue:,.0f} VNĐ&#10;            - **Tỷ lệ thanh toán:** {payment_rate:.1f}%&#10;            - **Số lượng hóa đơn:** {total_invoices}&#10;            - **Giá trị trung bình/hóa đơn:** {(total_revenue / total_invoices if total_invoices &gt; 0 else 0):,.0f} VNĐ&#10;&#10;            ## ĐIỂM MẠNH&#10;            - Nêu tối đa 3 ý ngắn gọn dựa trên dữ liệu trên.&#10;&#10;            ## VẤN ĐỀ CẦN LƯU Ý&#10;            - Nêu tối đa 3 ý ngắn gọn, tập trung rủi ro/điểm yếu.&#10;&#10;            ## KHUYẾN NGHỊ&#10;            - Đưa ra 3-4 gợi ý cụ thể, dễ hành động.&#10;&#10;            YÊU CẦU ĐỊNH DẠNG:&#10;            - Chỉ dùng dấu '-' cho bullet (không dùng '•', '—', '–' hay ký tự khác).&#10;            - Không có dòng trống thừa, không bọc trong ```.&#10;            - Không viết câu mở đầu/kết luận.&#10;            - Mỗi bullet tối đa 1-2 câu, ≤ 120 ký tự.&#10;            &quot;&quot;&quot;&#10;&#10;            response = self.model.generate_content(prompt)&#10;            return self._sanitize_markdown(response.text)&#10;&#10;        except Exception as e:&#10;            return f&quot;Không thể tạo báo cáo doanh thu: {str(e)}&quot;&#10;&#10;# Khởi tạo service&#10;ai_service = AIService()&#10;" />
              <option name="updatedContent" value="import google.generativeai as genai&#10;from ..core.config import settings&#10;from ..core.database import get_db&#10;from sqlalchemy import text&#10;import re&#10;&#10;class AIService:&#10;    def __init__(self):&#10;        # Cấu hình Gemini AI (dùng key từ config, không hardcode)&#10;        genai.configure(api_key=settings.gemini_api_key)&#10;        # Dùng model ổn định, phổ biến&#10;        self.model = genai.GenerativeModel('gemini-2.5-pro')&#10;&#10;    def _sanitize_markdown(self, content: str) -&gt; str:&#10;        &quot;&quot;&quot;Chuẩn hoá Markdown: chỉ dùng '-' cho bullet, bỏ ký tự lạ/emoji/fences, gọn dòng.&quot;&quot;&quot;&#10;        if not content:&#10;            return content&#10;        lines = content.splitlines()&#10;        out = []&#10;        for raw in lines:&#10;            line = raw.strip()&#10;            # Bỏ code fences&#10;            if line in (&quot;```&quot;, &quot;```markdown&quot;, &quot;```md&quot;):&#10;                continue&#10;            # Thay bullet lạ ở đầu dòng thành '- '&#10;            if re.match(r&quot;^[•—–]+\s*&quot;, line):&#10;                line = re.sub(r&quot;^[•—–]+\s*&quot;, &quot;- &quot;, line)&#10;            # Thay '•', '—', '–' xuất hiện đầu dòng sau khoảng trắng&#10;            line = re.sub(r&quot;^\s*[•—–]\s*&quot;, &quot;- &quot;, line)&#10;            # Chuẩn hoá bullet '-'&#10;            line = re.sub(r&quot;^\s*-\s*&quot;, &quot;- &quot;, line)&#10;            # Loại bỏ dòng chỉ gồm gạch trang trí&#10;            if re.fullmatch(r&quot;[-–—\s]+&quot;, line):&#10;                continue&#10;            # Bỏ emoji phổ biến ở đầu dòng tiêu đề&#10;            line = re.sub(r&quot;^(##\s*)[\u2600-\u27BF\U0001F300-\U0001FAFF]\s*&quot;, r&quot;\1&quot;, line)&#10;            # Bỏ emoji đầu dòng bullet&#10;            line = re.sub(r&quot;^(-\s*)[\u2600-\u27BF\U0001F300-\U0001FAFF]\s*&quot;, r&quot;\1&quot;, line)&#10;            out.append(line)&#10;        # Ghép lại và rút gọn nhiều dòng trống liên tiếp&#10;        text_out = &quot;\n&quot;.join(out)&#10;        text_out = re.sub(r&quot;\n{3,}&quot;, &quot;\n\n&quot;, text_out).strip()&#10;        return text_out&#10;&#10;    def generate_revenue_report(self, start_date: str, end_date: str, owner_id: int) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Tạo báo cáo doanh thu bằng AI (phạm vi theo chủ nhà đăng nhập)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            db = next(get_db())&#10;&#10;            # Tổng doanh thu (đã thanh toán) trong khoảng thời gian, theo owner&#10;            total_revenue_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COALESCE(SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price), 0) as total&#10;                FROM invoices i&#10;                JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                JOIN rooms r ON rr.room_id = r.room_id&#10;                JOIN houses h ON r.house_id = h.house_id&#10;                WHERE i.is_paid = TRUE &#10;                  AND i.payment_date BETWEEN :start_date AND :end_date&#10;                  AND h.owner_id = :owner_id&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            total_revenue = float(total_revenue_row.total or 0)&#10;&#10;            # Số hóa đơn đã thanh toán trong khoảng thời gian, theo owner&#10;            paid_invoices_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COUNT(*) as cnt&#10;                FROM invoices i&#10;                JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                JOIN rooms r ON rr.room_id = r.room_id&#10;                JOIN houses h ON r.house_id = h.house_id&#10;                WHERE i.is_paid = TRUE &#10;                  AND i.payment_date BETWEEN :start_date AND :end_date&#10;                  AND h.owner_id = :owner_id&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            paid_invoices = int(paid_invoices_row.cnt or 0)&#10;&#10;            # Số hóa đơn chưa thanh toán theo due_date trong khoảng thời gian, theo owner&#10;            pending_invoices_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COUNT(*) as cnt&#10;                FROM invoices i&#10;                JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                JOIN rooms r ON rr.room_id = r.room_id&#10;                JOIN houses h ON r.house_id = h.house_id&#10;                WHERE i.is_paid = FALSE &#10;                  AND i.due_date BETWEEN :start_date AND :end_date&#10;                  AND h.owner_id = :owner_id&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            pending_invoices = int(pending_invoices_row.cnt or 0)&#10;&#10;            # Doanh thu trung bình theo tháng (trong khoảng thời gian), theo owner&#10;            avg_month_row = db.execute(text(&#10;                &quot;&quot;&quot;&#10;                SELECT COALESCE(AVG(monthly_revenue), 0) as avg_rev&#10;                FROM (&#10;                    SELECT DATE_FORMAT(i.payment_date, '%Y-%m') as month,&#10;                           SUM(i.price + i.water_price + i.internet_price + i.general_price + i.electricity_price) as monthly_revenue&#10;                    FROM invoices i&#10;                    JOIN rented_rooms rr ON i.rr_id = rr.rr_id&#10;                    JOIN rooms r ON rr.room_id = r.room_id&#10;                    JOIN houses h ON r.house_id = h.house_id&#10;                    WHERE i.is_paid = TRUE &#10;                      AND i.payment_date BETWEEN :start_date AND :end_date&#10;                      AND h.owner_id = :owner_id&#10;                    GROUP BY DATE_FORMAT(i.payment_date, '%Y-%m')&#10;                ) t&#10;                &quot;&quot;&quot;&#10;            ), { 'start_date': start_date, 'end_date': end_date, 'owner_id': owner_id }).fetchone()&#10;            avg_monthly_revenue = float(avg_month_row.avg_rev or 0)&#10;&#10;            db.close()&#10;            &#10;            # Tính bổ sung&#10;            total_invoices = paid_invoices + pending_invoices&#10;            payment_rate = (paid_invoices / total_invoices * 100) if total_invoices &gt; 0 else 0&#10;&#10;            # Prompt chuẩn Markdown, KHÔNG emoji/ký tự lạ, KHÔNG câu mở đầu/kết luận&#10;            prompt = f&quot;&quot;&quot;&#10;            Bạn là chuyên gia phân tích doanh thu. Hãy trả lời bằng Markdown, đúng định dạng sau và KHÔNG thêm ký tự trang trí/emoji:&#10;&#10;            ## PHÂN TÍCH DOANH THU&#10;            - **Kỳ báo cáo:** {start_date} - {end_date}&#10;&#10;            ## CHỈ SỐ CHÍNH&#10;            - **Tổng doanh thu:** {total_revenue:,.0f} VNĐ&#10;            - **Tỷ lệ thanh toán:** {payment_rate:.1f}%&#10;            - **Số lượng hóa đơn:** {total_invoices}&#10;            - **Giá trị trung bình/hóa đơn:** {(total_revenue / total_invoices if total_invoices &gt; 0 else 0):,.0f} VNĐ&#10;&#10;            ## ĐIỂM MẠNH&#10;            - Nêu tối đa 3 ý ngắn gọn dựa trên dữ liệu trên.&#10;&#10;            ## VẤN ĐỀ CẦN LƯU Ý&#10;            - Nêu tối đa 3 ý ngắn gọn, tập trung rủi ro/điểm yếu.&#10;&#10;            ## KHUYẾN NGHỊ&#10;            - Đưa ra 3-4 gợi ý cụ thể, dễ hành động.&#10;&#10;            YÊU CẦU ĐỊNH DẠNG:&#10;            - Chỉ dùng dấu '-' cho bullet (không dùng '•', '—', '–' hay ký tự khác).&#10;            - Không có dòng trống thừa, không bọc trong ```.&#10;            - Không viết câu mở đầu/kết luận.&#10;            - Mỗi bullet tối đa 1-2 câu, ≤ 120 ký tự.&#10;            &quot;&quot;&quot;&#10;&#10;            response = self.model.generate_content(prompt)&#10;            return self._sanitize_markdown(response.text)&#10;&#10;        except Exception as e:&#10;            return f&quot;Không thể tạo báo cáo doanh thu: {str(e)}&quot;&#10;&#10;# Khởi tạo service&#10;ai_service = AIService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/database_setup.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/database_setup.sql" />
              <option name="originalContent" value="USE room_management_db;&#10;&#10;-- ============================================&#10;-- TRIGGERS (giữ để đảm bảo toàn vẹn dữ liệu và tự động hoá)&#10;-- ============================================&#10;&#10;-- 1. Trigger tự động cập nhật trạng thái phòng khi tạo hợp đồng thuê&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_insert_rented_room&#10;AFTER INSERT ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    UPDATE rooms &#10;    SET is_available = FALSE &#10;    WHERE room_id = NEW.room_id;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 2. Trigger tự động cập nhật trạng thái phòng khi chấm dứt hợp đồng&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_update_rented_room&#10;AFTER UPDATE ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.is_active = FALSE AND OLD.is_active = TRUE THEN&#10;        UPDATE rooms &#10;        SET is_available = TRUE &#10;        WHERE room_id = NEW.room_id;&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 3. Trigger tự động cập nhật ngày thanh toán khi đánh dấu hóa đơn đã thanh toán&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_update_invoice_paid&#10;AFTER UPDATE ON invoices&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.is_paid = TRUE AND OLD.is_paid = FALSE AND NEW.payment_date IS NULL THEN&#10;        UPDATE invoices &#10;        SET payment_date = NOW() &#10;        WHERE invoice_id = NEW.invoice_id;&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 4. Trigger tự động tạo hóa đơn tiền cọc cho hợp đồng mới&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_insert_rented_room_invoice&#10;AFTER INSERT ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    INSERT INTO invoices (&#10;        price,&#10;        water_price,&#10;        internet_price,&#10;        general_price,&#10;        electricity_price,&#10;        electricity_num,&#10;        water_num,&#10;        due_date,&#10;        rr_id,&#10;        is_paid,&#10;        created_at&#10;    ) VALUES (&#10;        NEW.deposit,&#10;        0,  -- Tiền nước mặc định&#10;        0,  -- Tiền internet mặc định&#10;        0,   -- Phí dịch vụ chung mặc định&#10;        0,  -- Tiền điện mặc định&#10;        0,       -- Số điện&#10;        0,       -- Số nước&#10;        DATE_ADD(NEW.start_date, INTERVAL 30 DAY),  -- Ngày đến hạn sau 30 ngày từ ngày bắt đầu&#10;        NEW.rr_id,&#10;        FALSE,&#10;        NOW()&#10;    );&#10;END //&#10;DELIMITER ;&#10;&#10;-- 5. Trigger kiểm tra tính hợp lệ của dữ liệu phòng&#10;DELIMITER //&#10;CREATE TRIGGER tr_before_insert_room&#10;BEFORE INSERT ON rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.capacity &lt;= 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Sức chứa phòng phải lớn hơn 0';&#10;    END IF;&#10;    &#10;    IF NEW.price &lt; 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Giá thuê phòng không được âm';&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 6. Trigger kiểm tra tính hợp lệ của hợp đồng thuê&#10;DELIMITER //&#10;CREATE TRIGGER tr_before_insert_rented_room&#10;BEFORE INSERT ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.end_date &lt;= NEW.start_date THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Ngày kết thúc phải sau ngày bắt đầu';&#10;    END IF;&#10;    &#10;    IF NEW.number_of_tenants &lt;= 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Số người thuê phải lớn hơn 0';&#10;    END IF;&#10;    &#10;    IF NEW.monthly_rent &lt; 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Tiền thuê hàng tháng không được âm';&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- ============================================&#10;-- INDEXES để tối ưu hiệu suất&#10;-- ============================================&#10;&#10;CREATE INDEX idx_rooms_house_id ON rooms(house_id);&#10;CREATE INDEX idx_rooms_is_available ON rooms(is_available);&#10;CREATE INDEX idx_rented_rooms_room_id ON rented_rooms(room_id);&#10;CREATE INDEX idx_rented_rooms_is_active ON rented_rooms(is_active);&#10;CREATE INDEX idx_invoices_rr_id ON invoices(rr_id);&#10;CREATE INDEX idx_invoices_is_paid ON invoices(is_paid);&#10;CREATE INDEX idx_invoices_payment_date ON invoices(payment_date);&#10;CREATE INDEX idx_assets_room_id ON assets(room_id);&#10;CREATE INDEX idx_houses_owner_id ON houses(owner_id);&#10;" />
              <option name="updatedContent" value="USE room_management_db;&#10;&#10;-- ============================================&#10;-- TRIGGERS (giữ để đảm bảo toàn vẹn dữ liệu và tự động hoá)&#10;-- ============================================&#10;&#10;-- 1. Trigger tự động cập nhật trạng thái phòng khi tạo hợp đồng thuê&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_insert_rented_room&#10;AFTER INSERT ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    UPDATE rooms &#10;    SET is_available = FALSE &#10;    WHERE room_id = NEW.room_id;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 2. Trigger tự động cập nhật trạng thái phòng khi chấm dứt hợp đồng&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_update_rented_room&#10;AFTER UPDATE ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.is_active = FALSE AND OLD.is_active = TRUE THEN&#10;        UPDATE rooms &#10;        SET is_available = TRUE &#10;        WHERE room_id = NEW.room_id;&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 3. Trigger tự động cập nhật ngày thanh toán khi đánh dấu hóa đơn đã thanh toán&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_update_invoice_paid&#10;AFTER UPDATE ON invoices&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.is_paid = TRUE AND OLD.is_paid = FALSE AND NEW.payment_date IS NULL THEN&#10;        UPDATE invoices &#10;        SET payment_date = NOW() &#10;        WHERE invoice_id = NEW.invoice_id;&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 4. Trigger tự động tạo hóa đơn tiền cọc cho hợp đồng mới&#10;DELIMITER //&#10;CREATE TRIGGER tr_after_insert_rented_room_invoice&#10;AFTER INSERT ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    INSERT INTO invoices (&#10;        price,&#10;        water_price,&#10;        internet_price,&#10;        general_price,&#10;        electricity_price,&#10;        electricity_num,&#10;        water_num,&#10;        due_date,&#10;        rr_id,&#10;        is_paid,&#10;        created_at&#10;    ) VALUES (&#10;        NEW.deposit,&#10;        0,  -- Tiền nước mặc định&#10;        0,  -- Tiền internet mặc định&#10;        0,   -- Phí dịch vụ chung mặc định&#10;        0,  -- Tiền điện mặc định&#10;        0,       -- Số điện&#10;        0,       -- Số nước&#10;        DATE_ADD(NEW.start_date, INTERVAL 30 DAY),  -- Ngày đến hạn sau 30 ngày từ ngày bắt đầu&#10;        NEW.rr_id,&#10;        FALSE,&#10;        NOW()&#10;    );&#10;END //&#10;DELIMITER ;&#10;&#10;-- 5. Trigger kiểm tra tính hợp lệ của dữ liệu phòng&#10;DELIMITER //&#10;CREATE TRIGGER tr_before_insert_room&#10;BEFORE INSERT ON rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.capacity &lt;= 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Sức chứa phòng phải lớn hơn 0';&#10;    END IF;&#10;    &#10;    IF NEW.price &lt; 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Giá thuê phòng không được âm';&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- 6. Trigger kiểm tra tính hợp lệ của hợp đồng thuê&#10;DELIMITER //&#10;CREATE TRIGGER tr_before_insert_rented_room&#10;BEFORE INSERT ON rented_rooms&#10;FOR EACH ROW&#10;BEGIN&#10;    IF NEW.end_date &lt;= NEW.start_date THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Ngày kết thúc phải sau ngày bắt đầu';&#10;    END IF;&#10;    &#10;    IF NEW.number_of_tenants &lt;= 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Số người thuê phải lớn hơn 0';&#10;    END IF;&#10;    &#10;    IF NEW.monthly_rent &lt; 0 THEN&#10;        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Tiền thuê hàng tháng không được âm';&#10;    END IF;&#10;END //&#10;DELIMITER ;&#10;&#10;-- ============================================&#10;-- INDEXES để tối ưu hiệu suất&#10;-- ============================================&#10;&#10;CREATE INDEX idx_rooms_house_id ON rooms(house_id);&#10;CREATE INDEX idx_rooms_is_available ON rooms(is_available);&#10;CREATE INDEX idx_rented_rooms_room_id ON rented_rooms(room_id);&#10;CREATE INDEX idx_rented_rooms_is_active ON rented_rooms(is_active);&#10;CREATE INDEX idx_invoices_rr_id ON invoices(rr_id);&#10;CREATE INDEX idx_invoices_is_paid ON invoices(is_paid);&#10;CREATE INDEX idx_invoices_payment_date ON invoices(payment_date);&#10;CREATE INDEX idx_assets_room_id ON assets(room_id);&#10;CREATE INDEX idx_houses_owner_id ON houses(owner_id);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/Register.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/Register.js" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { Form, Input, Button, Card, Typography, message } from 'antd';&#10;import { UserOutlined, MailOutlined, PhoneOutlined, LockOutlined } from '@ant-design/icons';&#10;import { authService } from '../services/authService';&#10;&#10;const { Title } = Typography;&#10;&#10;const Register = () =&gt; {&#10;  const [loading, setLoading] = useState(false);&#10;  const navigate = useNavigate();&#10;  const [form] = Form.useForm();&#10;&#10;  const onFinish = async (values) =&gt; {&#10;    if (values.password !== values.confirmPassword) {&#10;      message.error('Mật khẩu xác nhận không khớp');&#10;      return;&#10;    }&#10;    setLoading(true);&#10;    try {&#10;      const { fullname, phone, email, password } = values;&#10;      await authService.register({ fullname, phone, email, password });&#10;      message.success('Đăng ký thành công! Vui lòng đăng nhập.');&#10;      navigate('/login');&#10;    } catch (err) {&#10;      const res = err?.response;&#10;      const status = res?.status;&#10;      const data = res?.data;&#10;&#10;      // 422: FastAPI validation errors&#10;      if (status === 422 &amp;&amp; Array.isArray(data?.detail)) {&#10;        const msgs = data.detail.map((e) =&gt; e.msg).filter(Boolean);&#10;        const combined = msgs.join('\n');&#10;        message.error(combined || 'Dữ liệu không hợp lệ. Vui lòng kiểm tra lại.');&#10;      } else if (status === 400) {&#10;        // 400: Often duplicate or bad request; surface detail if possible&#10;        let detailText = '';&#10;        if (typeof data?.detail === 'string') detailText = data.detail;&#10;        else if (Array.isArray(data?.detail)) detailText = data.detail.map((e) =&gt; e.msg).join('\n');&#10;        else if (typeof data === 'string') detailText = data; // e.g., HTML/text body&#10;&#10;        const dupMap = {&#10;          'Email already registered': 'Email đã được sử dụng.',&#10;          'Phone already registered': 'Số điện thoại đã được sử dụng.',&#10;          'Email or Phone already registered': 'Email hoặc số điện thoại đã tồn tại.'&#10;        };&#10;&#10;        if (detailText in dupMap) {&#10;          const vi = dupMap[detailText];&#10;          message.error(vi);&#10;          // Inline errors on fields for better UX&#10;          const fields = [];&#10;          if (detailText.includes('Email')) fields.push({ name: 'email', errors: [vi] });&#10;          if (detailText.includes('Phone')) fields.push({ name: 'phone', errors: [vi] });&#10;          if (fields.length === 0) fields.push({ name: 'email', errors: [vi] }, { name: 'phone', errors: [vi] });&#10;          form.setFields(fields);&#10;        } else if (detailText) {&#10;          message.error(detailText);&#10;        } else {&#10;          const vi = 'Dữ liệu đã tồn tại trong hệ thống hoặc không hợp lệ.';&#10;          message.error(vi);&#10;          form.setFields([&#10;            { name: 'email', errors: [vi] },&#10;            { name: 'phone', errors: [vi] }&#10;          ]);&#10;        }&#10;      } else {&#10;        // Other statuses or missing response&#10;        const fallback = (typeof data?.detail === 'string' &amp;&amp; data.detail) ||&#10;                         (typeof data === 'string' &amp;&amp; data) ||&#10;                         err?.message ||&#10;                         'Đăng ký thất bại. Vui lòng thử lại.';&#10;        message.error(fallback);&#10;      }&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  // Strong password helper validator&#10;  const passwordRules = [&#10;    { required: true, message: 'Vui lòng nhập mật khẩu' },&#10;    { min: 8, message: 'Mật khẩu tối thiểu 8 ký tự' },&#10;    ({ getFieldValue }) =&gt; ({&#10;      validator(_, value) {&#10;        if (!value) return Promise.resolve();&#10;        const hasUpper = /[A-Z]/.test(value);&#10;        const hasLower = /[a-z]/.test(value);&#10;        const hasDigit = /\d/.test(value);&#10;        const hasSpecial = /[^A-Za-z0-9]/.test(value);&#10;        if (hasUpper &amp;&amp; hasLower &amp;&amp; hasDigit &amp;&amp; hasSpecial) return Promise.resolve();&#10;        return Promise.reject(&#10;          new Error('Mật khẩu phải có chữ hoa, chữ thường, số và ký tự đặc biệt')&#10;        );&#10;      },&#10;    }),&#10;  ];&#10;&#10;  return (&#10;    &lt;div style={{&#10;      minHeight: '100vh',&#10;      display: 'flex',&#10;      alignItems: 'center',&#10;      justifyContent: 'center',&#10;      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'&#10;    }}&gt;&#10;      &lt;Card style={{ width: 480, boxShadow: '0 4px 12px rgba(0,0,0,0.15)' }}&gt;&#10;        &lt;div style={{ textAlign: 'center', marginBottom: 24 }}&gt;&#10;          &lt;Title level={2} style={{ color: '#1890ff' }}&gt;&#10;            Đăng ký tài khoản&#10;          &lt;/Title&gt;&#10;          &lt;p style={{ color: '#666', marginBottom: 0 }}&gt;&#10;            Điền thông tin để tạo tài khoản chủ trọ&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;Form layout=&quot;vertical&quot; form={form} onFinish={onFinish} size=&quot;large&quot;&gt;&#10;          &lt;Form.Item&#10;            label=&quot;Họ và tên&quot;&#10;            name=&quot;fullname&quot;&#10;            rules={[&#10;              { required: true, message: 'Vui lòng nhập họ và tên' },&#10;              { min: 3, message: 'Họ tên phải có ít nhất 3 ký tự' }&#10;            ]}&#10;          &gt;&#10;            &lt;Input prefix={&lt;UserOutlined /&gt;} placeholder=&quot;Ví dụ: Nguyễn Văn A&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Số điện thoại&quot;&#10;            name=&quot;phone&quot;&#10;            rules={[&#10;              { required: true, message: 'Vui lòng nhập số điện thoại' },&#10;              { pattern: /^\d{10,11}$/, message: 'Số điện thoại không hợp lệ (10-11 chữ số)' }&#10;            ]}&#10;          &gt;&#10;            &lt;Input prefix={&lt;PhoneOutlined /&gt;} placeholder=&quot;Ví dụ: 0912345678&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Email&quot;&#10;            name=&quot;email&quot;&#10;            rules={[&#10;              { required: true, message: 'Vui lòng nhập email' },&#10;              { type: 'email', message: 'Email không hợp lệ' }&#10;            ]}&#10;          &gt;&#10;            &lt;Input prefix={&lt;MailOutlined /&gt;} placeholder=&quot;you@example.com&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Mật khẩu&quot;&#10;            name=&quot;password&quot;&#10;            rules={passwordRules}&#10;            hasFeedback&#10;          &gt;&#10;            &lt;Input.Password prefix={&lt;LockOutlined /&gt;} placeholder=&quot;Nhập mật khẩu&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Xác nhận mật khẩu&quot;&#10;            name=&quot;confirmPassword&quot;&#10;            dependencies={['password']}&#10;            hasFeedback&#10;            rules={[&#10;              { required: true, message: 'Vui lòng xác nhận mật khẩu' },&#10;              ({ getFieldValue }) =&gt; ({&#10;                validator(_, value) {&#10;                  if (!value || getFieldValue('password') === value) {&#10;                    return Promise.resolve();&#10;                  }&#10;                  return Promise.reject(new Error('Mật khẩu xác nhận không khớp'));&#10;                },&#10;              }),&#10;            ]}&#10;          &gt;&#10;            &lt;Input.Password prefix={&lt;LockOutlined /&gt;} placeholder=&quot;Nhập lại mật khẩu&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&gt;&#10;            &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot; loading={loading} style={{ width: '100%' }}&gt;&#10;              Đăng ký&#10;            &lt;/Button&gt;&#10;          &lt;/Form.Item&gt;&#10;        &lt;/Form&gt;&#10;&#10;        &lt;div style={{ textAlign: 'center' }}&gt;&#10;          &lt;Button type=&quot;link&quot; onClick={() =&gt; navigate('/login')}&gt;&#10;            Đã có tài khoản? Đăng nhập&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/Card&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default Register;&#10;" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { Form, Input, Button, Card, Typography, App } from 'antd';&#10;import { UserOutlined, MailOutlined, PhoneOutlined, LockOutlined } from '@ant-design/icons';&#10;import { authService } from '../services/authService';&#10;&#10;const { Title } = Typography;&#10;&#10;const Register = () =&gt; {&#10;  const { message } = App.useApp(); // Use App context for message&#10;  const [loading, setLoading] = useState(false);&#10;  const navigate = useNavigate();&#10;  const [form] = Form.useForm();&#10;&#10;  const onFinish = async (values) =&gt; {&#10;    if (values.password !== values.confirmPassword) {&#10;      message.error('Mật khẩu xác nhận không khớp');&#10;      return;&#10;    }&#10;    setLoading(true);&#10;    try {&#10;      const { fullname, phone, email, password } = values;&#10;      await authService.register({ fullname, phone, email, password });&#10;      message.success('Đăng ký thành công! Vui lòng đăng nhập.');&#10;      navigate('/login');&#10;    } catch (err) {&#10;      const res = err?.response;&#10;      const status = res?.status;&#10;      const data = res?.data;&#10;&#10;      // 422: FastAPI validation errors&#10;      if (status === 422 &amp;&amp; Array.isArray(data?.detail)) {&#10;        const msgs = data.detail.map((e) =&gt; e.msg).filter(Boolean);&#10;        const combined = msgs.join('\n');&#10;        message.error(combined || 'Dữ liệu không hợp lệ. Vui lòng kiểm tra lại.');&#10;      } else if (status === 400) {&#10;        // 400: Often duplicate or bad request; surface detail if possible&#10;        let detailText = '';&#10;        if (typeof data?.detail === 'string') detailText = data.detail;&#10;        else if (Array.isArray(data?.detail)) detailText = data.detail.map((e) =&gt; e.msg).join('\n');&#10;        else if (typeof data === 'string') detailText = data; // e.g., HTML/text body&#10;&#10;        const dupMap = {&#10;          'Email already registered': 'Email đã được sử dụng.',&#10;          'Phone already registered': 'Số điện thoại đã được sử dụng.',&#10;          'Email or Phone already registered': 'Email hoặc số điện thoại đã tồn tại.'&#10;        };&#10;&#10;        if (detailText in dupMap) {&#10;          const vi = dupMap[detailText];&#10;          message.error(vi);&#10;          // Inline errors on fields for better UX&#10;          const fields = [];&#10;          if (detailText.includes('Email')) fields.push({ name: 'email', errors: [vi] });&#10;          if (detailText.includes('Phone')) fields.push({ name: 'phone', errors: [vi] });&#10;          if (fields.length === 0) fields.push({ name: 'email', errors: [vi] }, { name: 'phone', errors: [vi] });&#10;          form.setFields(fields);&#10;        } else if (detailText) {&#10;          message.error(detailText);&#10;        } else {&#10;          const vi = 'Dữ liệu đã tồn tại trong hệ thống hoặc không hợp lệ.';&#10;          message.error(vi);&#10;          form.setFields([&#10;            { name: 'email', errors: [vi] },&#10;            { name: 'phone', errors: [vi] }&#10;          ]);&#10;        }&#10;      } else {&#10;        // Other statuses or missing response&#10;        const fallback = (typeof data?.detail === 'string' &amp;&amp; data.detail) ||&#10;                         (typeof data === 'string' &amp;&amp; data) ||&#10;                         err?.message ||&#10;                         'Đăng ký thất bại. Vui lòng thử lại.';&#10;        message.error(fallback);&#10;      }&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  // Strong password helper validator&#10;  const passwordRules = [&#10;    { required: true, message: 'Vui lòng nhập mật khẩu' },&#10;    { min: 8, message: 'Mật khẩu tối thiểu 8 ký tự' },&#10;    ({ getFieldValue }) =&gt; ({&#10;      validator(_, value) {&#10;        if (!value) return Promise.resolve();&#10;        const hasUpper = /[A-Z]/.test(value);&#10;        const hasLower = /[a-z]/.test(value);&#10;        const hasDigit = /\d/.test(value);&#10;        const hasSpecial = /[^A-Za-z0-9]/.test(value);&#10;        if (hasUpper &amp;&amp; hasLower &amp;&amp; hasDigit &amp;&amp; hasSpecial) return Promise.resolve();&#10;        return Promise.reject(&#10;          new Error('Mật khẩu phải có chữ hoa, chữ thường, số và ký tự đặc biệt')&#10;        );&#10;      },&#10;    }),&#10;  ];&#10;&#10;  return (&#10;    &lt;div style={{&#10;      minHeight: '100vh',&#10;      display: 'flex',&#10;      alignItems: 'center',&#10;      justifyContent: 'center',&#10;      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'&#10;    }}&gt;&#10;      &lt;Card style={{ width: 480, boxShadow: '0 4px 12px rgba(0,0,0,0.15)' }}&gt;&#10;        &lt;div style={{ textAlign: 'center', marginBottom: 24 }}&gt;&#10;          &lt;Title level={2} style={{ color: '#1890ff' }}&gt;&#10;            Đăng ký tài khoản&#10;          &lt;/Title&gt;&#10;          &lt;p style={{ color: '#666', marginBottom: 0 }}&gt;&#10;            Điền thông tin để tạo tài khoản chủ trọ&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;Form layout=&quot;vertical&quot; form={form} onFinish={onFinish} size=&quot;large&quot;&gt;&#10;          &lt;Form.Item&#10;            label=&quot;Họ và tên&quot;&#10;            name=&quot;fullname&quot;&#10;            rules={[&#10;              { required: true, message: 'Vui lòng nhập họ và tên' },&#10;              { min: 3, message: 'Họ tên phải có ít nhất 3 ký tự' }&#10;            ]}&#10;          &gt;&#10;            &lt;Input prefix={&lt;UserOutlined /&gt;} placeholder=&quot;Ví dụ: Nguyễn Văn A&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Số điện thoại&quot;&#10;            name=&quot;phone&quot;&#10;            rules={[&#10;              { required: true, message: 'Vui lòng nhập số điện thoại' },&#10;              { pattern: /^\d{10,11}$/, message: 'Số điện thoại không hợp lệ (10-11 chữ số)' }&#10;            ]}&#10;          &gt;&#10;            &lt;Input prefix={&lt;PhoneOutlined /&gt;} placeholder=&quot;Ví dụ: 0912345678&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Email&quot;&#10;            name=&quot;email&quot;&#10;            rules={[&#10;              { required: true, message: 'Vui lòng nhập email' },&#10;              { type: 'email', message: 'Email không hợp lệ' }&#10;            ]}&#10;          &gt;&#10;            &lt;Input prefix={&lt;MailOutlined /&gt;} placeholder=&quot;you@example.com&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Mật khẩu&quot;&#10;            name=&quot;password&quot;&#10;            rules={passwordRules}&#10;            hasFeedback&#10;          &gt;&#10;            &lt;Input.Password prefix={&lt;LockOutlined /&gt;} placeholder=&quot;Nhập mật khẩu&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&#10;            label=&quot;Xác nhận mật khẩu&quot;&#10;            name=&quot;confirmPassword&quot;&#10;            dependencies={['password']}&#10;            hasFeedback&#10;            rules={[&#10;              { required: true, message: 'Vui lòng xác nhận mật khẩu' },&#10;              ({ getFieldValue }) =&gt; ({&#10;                validator(_, value) {&#10;                  if (!value || getFieldValue('password') === value) {&#10;                    return Promise.resolve();&#10;                  }&#10;                  return Promise.reject(new Error('Mật khẩu xác nhận không khớp'));&#10;                },&#10;              }),&#10;            ]}&#10;          &gt;&#10;            &lt;Input.Password prefix={&lt;LockOutlined /&gt;} placeholder=&quot;Nhập lại mật khẩu&quot; /&gt;&#10;          &lt;/Form.Item&gt;&#10;&#10;          &lt;Form.Item&gt;&#10;            &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot; loading={loading} style={{ width: '100%' }}&gt;&#10;              Đăng ký&#10;            &lt;/Button&gt;&#10;          &lt;/Form.Item&gt;&#10;        &lt;/Form&gt;&#10;&#10;        &lt;div style={{ textAlign: 'center' }}&gt;&#10;          &lt;Button type=&quot;link&quot; onClick={() =&gt; navigate('/login')}&gt;&#10;            Đã có tài khoản? Đăng nhập&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/Card&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default Register;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/aiService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/aiService.js" />
              <option name="originalContent" value="import api from './api';&#10;&#10;export const aiService = {&#10;  generateRevenueReport: async (startDate, endDate) =&gt; {&#10;    const response = await api.post('/ai/generate-revenue-report', {&#10;      start_date: startDate,&#10;      end_date: endDate&#10;    });&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export default aiService;" />
              <option name="updatedContent" value="import api from './api';&#13;&#10;&#13;&#10;export const aiService = {&#13;&#10;  generateRevenueReport: async (startDate, endDate) =&gt; {&#13;&#10;    const response = await api.post('/ai/generate-revenue-report', {&#13;&#10;      start_date: startDate,&#13;&#10;      end_date: endDate&#13;&#10;    });&#13;&#10;    return response.data;&#13;&#10;  }&#13;&#10;};&#13;&#10;&#13;&#10;export default aiService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/reportsService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/reportsService.js" />
              <option name="originalContent" value="import api from './api';&#10;&#10;export const reportsService = {&#10;  getSystemOverview: async () =&gt; {&#10;    const response = await api.get('/reports/system-overview');&#10;    return response.data;&#10;  },&#10;&#10;  getRevenueStats: async (startDate, endDate) =&gt; {&#10;    const response = await api.post('/reports/revenue-stats', {&#10;      start_date: startDate,&#10;      end_date: endDate&#10;    });&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export default reportsService;" />
              <option name="updatedContent" value="import api from './api';&#13;&#10;&#13;&#10;export const reportsService = {&#13;&#10;  getSystemOverview: async () =&gt; {&#13;&#10;    const response = await api.get('/reports/system-overview');&#13;&#10;    return response.data;&#13;&#10;  },&#13;&#10;&#13;&#10;  getRevenueStats: async (startDate, endDate) =&gt; {&#13;&#10;    const response = await api.post('/reports/revenue-stats', {&#13;&#10;      start_date: startDate,&#13;&#10;      end_date: endDate&#13;&#10;    });&#13;&#10;    return response.data;&#13;&#10;  }&#13;&#10;};&#13;&#10;&#13;&#10;export default reportsService;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>